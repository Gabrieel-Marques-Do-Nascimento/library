use collections::HashMap;
use convert_case::{Case, Casing};
use serde::{Deserialize, Serialize};
use serde_json::Result;
use std::{collections, fs};

#[derive(Serialize, Deserialize, Debug)]
struct Attr {
    is_branch: Option<bool>,
    is_segment: Option<bool>,
    is_keyword: Option<bool>,
    is_condition: Option<bool>,
    is_nop: Option<bool>,
    is_unsupported: Option<bool>,
    is_constructor: Option<bool>,
    is_destructor: Option<bool>,
    is_static: Option<bool>,
    is_overload: Option<bool>,
    is_variadic: Option<bool>,
}

#[derive(Serialize, Deserialize, Debug)]
struct Param {
    r#type: String,
    r#name: String,
}

#[derive(Serialize, Deserialize, Debug)]
struct Command {
    id: String,
    name: String,
    attrs: Attr,
    num_params: i32,
    input: Vec<Param>,
    output: Vec<Param>,
    class: Option<String>,
    member: Option<String>,
    short_desc: String,
}

#[derive(Serialize, Deserialize, Debug)]
struct Extension {
    name: String,
    commands: Vec<Command>,
}

#[derive(Serialize, Deserialize, Debug)]
struct Meta {
    last_update: u64,
}

#[derive(Serialize, Deserialize, Debug)]
struct Library {
    meta: Meta,
    extensions: Vec<Extension>,
}

fn main() -> Result<()> {
    let args: Vec<String> = std::env::args().collect();
    let input_file = args
        .get(1)
        .unwrap_or_else(|| panic!("Provide input file name"));

    let content = fs::read_to_string(input_file).unwrap();
    let library = serde_json::from_str::<Library>(content.as_str())?;

    let commands = library
        .extensions
        .iter()
        .flat_map(|ext| ext.commands.iter())
        .collect::<Vec<_>>();

    let mut classes_list: HashMap<String, HashMap<String, String>> = HashMap::new();

    for command in commands {
        if !command.class.is_some() || !command.member.is_some() {
            continue;
        }

        let class_name = command.class.as_ref().unwrap().to_case(Case::Pascal);
        let class_member = command.member.as_ref().unwrap().to_case(Case::Pascal);

        if !classes_list.contains_key(&class_name) {
            classes_list.insert(class_name.clone(), HashMap::new());
        }

        let map = classes_list.get_mut(&class_name).unwrap();

        let is_condition = if command.attrs.is_condition.is_some() {
            1
        } else {
            0
        };

        let params: Vec<String> = command
            .input
            .iter()
            .chain(command.output.iter())
            .map(|p| {
                if p.name.len() == 0 {
                    String::from("")
                } else {
                    let _type = match p.r#type.to_ascii_lowercase().as_str() {
                        "float" => String::from("%f"),
                        "int" => String::from("%i"),
                        "string" => String::from("%s"),
                        "bool" | "boolean" => String::from("%b"),
                        _ => format!(": {}", p.r#type),
                    };
                    format!("\"{}{}\"", p.name, _type)
                }
            })
            .collect();

        let description = format!(
            "{},{},{},({})",
            command.id.trim(),
            is_condition,
            0,
            params.join(" ")
        );
        map.insert(class_member, description);
    }

    let mut classes_names: Vec<&str> = classes_list.keys().map(|line| line.trim()).collect();
    classes_names.sort();

    println!("; autogenerated from {}\n", input_file);
    println!("#CLASSESLIST");

    for class_name in classes_names.iter() {
        println!("{}", class_name);
    }

    println!("\n#CLASSES");

    for &class_name in classes_names.iter() {
        println!("${}", class_name.trim());
        println!("$BEGIN");

        let members = classes_list.get(class_name).unwrap();
        let mut member_names: Vec<&String> = members.keys().collect();
        member_names.sort();

        for member_name in member_names {
            let description = members.get(member_name).unwrap();
            println!("{},{}", member_name, description);
        }

        println!("$END\n");
    }

    println!("#EOF");

    Ok(())
}
